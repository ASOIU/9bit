---
layout: post
wp_id:  3098
title:  'Лямбда выражения в Java 8'
author: vadim
date:             2013-10-08 04:49:10 +0000
last_modified_at: 2014-07-29 09:07:51 +0000
redirect_from: 
  - /excerpt/3098.html
categories: 
  - Без рубрики
tags: 
---
<h1>Теория</h1>
<p>&nbsp;</p>
<p dir="ltr">Лямбда-функции - это функции, у которой фактически нет имени. Математики упростили до невозможности формат записи функции:</p>
<p dir="ltr">λx.x</p>
<p dir="ltr">λ означает, что это лямбда-функция. Всё что после неё - список аргументов, в идеале абсолютно любого типа, в том числе может быть и другая лямбда-функция. После точки идёт "тело функции", а уже потом, собственно, идёт аргумент, который будет передан.</p>
<p dir="ltr">λx.x+2 2 // вернёт 4</p>
<p dir="ltr">λx.x 2 λy.y+1 // результат 3</p>
<p dir="ltr">В последнем примере в качестве параметра x выступает другая лямбда-функция λy.y+1, в которую передаётся параметр 2. Т.е. любая лямбда функция является функцией высшего порядка, может принимать в качестве аргумента другую функцию и возвращать функцию:</p>
<p dir="ltr">λx.λy.y+x+3 2 // вернёт λy.y+5, т.к. x был равен двум.</p>
<p>λx.λy.y+x+3 2 3 // вернёт 8. Фактически это каррирование: сначала функция принимает аргумент 2 и возвращает функцию, которая принимает ещё один аргумент и возвращает результат.</p>
<h1>Лямба функции в Java 8</h1>
<p dir="ltr">Синтаксис очень похож на то что используется в других языках, таких как coffeescript, scala и т.д.</p>
<p dir="ltr">(type parameter) -&gt; function_body</p>
<p>&nbsp;</p>
<p dir="ltr">Comparator&lt;Integer&gt; cmp = (x, y) -&gt; (x &lt; y) ? -1 : (x &gt; y) ? 1 : 0;</p>
<p>&nbsp;</p>
<p dir="ltr">Эта конструкция заменяет громоздкий код:</p>
<p>&nbsp;</p>
<p dir="ltr">Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt; () {<br />
public int compare(Integer x, Integer y) {<br />
return (x &lt; y) ? -1 : (x &gt; y) ? 1 : 0;<br />
}<br />
};</p>
<p>&nbsp;</p>
<p dir="ltr">У лямбда-выражений есть ряд интересных свойств. Одно из них состоит в том, что они являются замыканиями. Замыкание обеспечивает для функции доступ к переменным, находящимся вне ее области видимости. При реализации внутристрочных сценариев лямбда-выражения могут быть очень удобны.</p>
<p dir="ltr">String outer = "Java 8"<br />
(String s1) -&gt; s1.length() - outer.length()</p>
<p>&nbsp;</p>
<p dir="ltr">Другое очень приятное свойство это выведение типов. Не обязательно указывать тип везде, где компилятор сам может вывести тип — то есть определить его дедуктивным методом.  Основная польза от этого в сокращении шаблонного кода. Если компилятор способен вывести тип за нас — зачем нам самим это делать?</p>
<p dir="ltr">List&lt;String&gt; list = Arrays.asList(...);<br />
Collections.sort(list, (s1, s2) -&gt; s1.length() - s2.length());</p>
<p>&nbsp;</p>
<h1>Применение</h1>
<p dir="ltr">Лямба-функции очень удобно использовать при сортировки в качестве компаратора. Забудьте про циклы, итерации теперь абстрагированы. Что это нам дает? Не нужно изобретать велосипед и  писать паралельную переборку коллекции, поскольку базовая реализация цикла уже содержит её.</p>
<p dir="ltr">Array.asList(...).parallel().foreach(int i -&gt; cmp());</p>
<p>&nbsp;</p>
<p dir="ltr">В примере выше также используется такая интересная вешь как цепочка вызовов. Реализуется это путем возвращения из функции объекта коллекции, к которому снова можно применить другой метод (такой как map, reduce  и т.п.). Благодоря этому код читается и воспринимается очень быстро, практически  как обычный текст.</p>
<p>&nbsp;</p>
<p dir="ltr">В Swing-е теперь на замену анонимных классов придут анонимные функции:<br />
ActionListener listener = (ActionEvent e)-&gt;{ foo(e); };<br />
button.addActionListener(listener);</p>
<p>&nbsp;</p>
<h3>Итог</h3>
<p dir="ltr">Теперь пользователям Java 8 стали доступны многие удобное вещи, существовавшие в других языках.  Анонимные функции, обкатанные в Scala мигрировали в Java. Это безусловно хорошее решение, которое позволит писать больше компактного и понятного кода.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

